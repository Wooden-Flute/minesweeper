## 扫雷游戏逻辑

扫雷里，一个格子只有三种 **可见结果** ：

- 数字格

  - 周围 1–8 个雷
- 空白格

  - 周围 0 个雷（显示为空）
- 地雷

  - 直接失败

关键规则只有一条：

**当你点到一个“空白格（周围雷数为 0）”时，它周围 8 个方向的格子会被自动翻开。**

如果这些被翻开的格子里还有周围雷数为 0 的格子就继续向外扩散


## 扫雷功能拆解窗口与图形界面模块

功能
创建主窗口
设置窗口大小不可随意拉伸
加载位图资源（格子、数字、地雷、旗帜）
处理 WM_PAINT 重绘

设计建议
使用固定格子大小（如 20×20）
用二维数组保存每个格子的状态
绘图时根据状态直接查表绘制


### 鼠标与用户交互模块

功能
左键点击：翻开格子
右键点击：插旗 / 取消旗
双击或组合键：高级玩法（可选）

消息
WM_LBUTTONDOWN
WM_RBUTTONDOWN

关键点
鼠标坐标 → 格子索引转换
边界检查


### 扫雷核心逻辑模块

需要的数据结构
二维数组 board
每个格子至少包含
是否有雷
是否已翻开
是否插旗
周围雷数量

功能
随机布雷（保证首点安全）
计算周围雷数
翻开格子
递归 / 栈模拟展开空白区域
胜利条件判断
失败条件处理



### 游戏流程与状态管理模块

游戏状态
未开始
进行中
胜利
失败

功能
首次点击触发布雷
计时器开始
结束时禁止继续操作
弹窗提示结果


### 声音模块

功能
点击音效
翻雷爆炸音效
胜利音效

实现方式
PlaySound

直接用 wav 文件
事件触发播放即可


### 资源管理模块

资源类型
位图 bmp
声音 wav

管理方式
编译进资源文件（.rc）
或外部文件加载

推荐
使用 .rc 文件
更“正规工程”

## 任务分工

一人负责 **界面 + Win32 消息层**
一人负责 **核心扫雷逻辑（纯算法）**
一人负责 **功能整合（计时 / 声音 / 资源）**

---

组员 A：窗口、图形界面与鼠标交互负责人（前端）

负责模块
窗口与图形界面模块
鼠标与用户交互模块
绘图性能优化相关内容

具体任务
用 MASM + Win32 API 创建主窗口
设置固定窗口大小，禁用最大化
建立消息循环，处理 WM_PAINT
加载位图资源（bmp）
根据二维数组状态绘制格子
处理 WM_LBUTTONDOWN / WM_RBUTTONDOWN
完成 鼠标坐标 → 格子索引 的转换
只重绘被点击的格子区域（InvalidateRect）

需要和其他成员约定的接口
提供一个 draw_cell(x, y, state) 接口
从核心逻辑模块读取 board[x][y] 状态
鼠标事件只做“坐标转换 + 调用逻辑接口”，不写游戏规则

交付成果
一个可以显示网格、点击格子、根据状态变化重绘的窗口
即使逻辑是假的，也能正常显示（可以加入假逻辑，但要加好注释，便于整合）

---

组员 B：扫雷核心逻辑负责人（后端，最关键）

负责模块
扫雷核心逻辑模块
游戏流程与状态管理模块

具体任务
设计 board 数据结构（二维数组或一维映射） board[y][x]
定义格子状态字段
实现随机布雷（保证首点安全）
计算每个格子周围雷数
翻开格子逻辑
空白区域展开（非递归优先，栈或队列）
插旗 / 取消旗逻辑
胜利条件检测
失败处理（触雷）
维护游戏状态（未开始 / 进行中 / 胜利 / 失败）

开发方式建议
先写一个 **无界面、控制台版本扫雷**
通过打印数组验证算法正确性
确认逻辑稳定后，再给界面调用

需要提供的接口函数（示例）
init_game(width, height, mine_count)

click_cell(x, y)
toggle_flag(x, y)
get_cell_state(x, y)

get_game_state()

交付成果
一个**完全不依赖 Win32 的扫雷逻辑模块**

---

组员 C：计时、声音、资源与工程整合

负责模块
计时与计分模块
声音模块
资源管理模块
工程整合与测试支持

具体任务
设计计时逻辑
SetTimer / KillTimer
处理 WM_TIMER 消息
将用时显示到界面（与 A 协作）

实现声音播放
点击音效
翻雷爆炸音效
胜利音效
统一用 PlaySound + wav 文件

管理资源
编写 .rc 资源文件
统一管理 bmp / wav 的 ID
封装资源加载接口

协助整体整合
把 A 的界面、B 的逻辑模块连接起来
做完整流程测试
