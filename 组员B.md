# 扫雷核心逻辑模块说明文档

## 1. 模块概述
本模块实现了扫雷游戏的核心逻辑，包括棋盘初始化、布雷、计算周围雷数、点击翻开格子（含递归展开空白区域）、插旗/取消旗、以及游戏胜利/失败状态的判定。
目前提供了一个基于控制台的测试界面，用于验证逻辑正确性。

## 2. 关键数据结构

### 2.1 全局变量
*   **`board_grid` (BYTE 数组, 400 字节)**
    *   这是游戏的核心数据，表示 10x10 的棋盘。
    *   每个格子占用 **4 字节**，结构如下：
        *   **Byte 0**: 是否有雷 (1=有, 0=无)
        *   **Byte 1**: 是否已翻开 (1=是, 0=否)
        *   **Byte 2**: 是否插旗 (1=是, 0=否)
        *   **Byte 3**: 周围雷数 (0-8)
    *   访问方式：`offset = (row * 40 + col*10)`

*   **`game_state` (BYTE)**
    *   当前游戏状态：
        *   `0`: 未开始
        *   `1`: 进行中
        *   `2`: 失败 (踩雷)
        *   `3`: 胜利 (所有非雷格子均已翻开)

*   **`mines_left` (BYTE)**
    *   剩余雷数计数器（初始为 10）。
    *   插旗时减 1，取消旗时加 1。主要用于界面显示剩余雷数。

*   **`cells_left` (BYTE)**
    *   剩余未翻开的**非雷**格子数（初始为 90）。
    *   每成功翻开一个安全格子，此值减 1。
    *   **胜利条件**：当 `cells_left` 减为 0 时，游戏胜利。

## 3. 核心函数接口

### 3.1 初始化与工具
*   **`r_places_mines`**
    *   功能：随机在棋盘上布置 10 个地雷。
    *   实现：使用线性同余法生成伪随机数，确保不重复布雷。
*   **`calc_around_mines`**
    *   功能：遍历整个棋盘，计算每个非雷格子周围 8 个方向的地雷总数，并存入 Byte 3。

### 3.2 游戏操作
*   **`click_cell(x, y)`**
    *   功能：处理玩家点击格子的操作。
    *   参数：`x` (行号 0-9), `y` (列号 0-9)。
    *   逻辑：
        1.  如果格子已翻开或已插旗，直接返回。
        2.  如果格子有雷，设置 `game_state = 2` (失败)。
        3.  如果格子安全，调用 `expand_blank` 进行翻开。
*   **`toggle_flag(x, y)`**
    *   功能：在指定格子插旗或取消旗。
    *   参数：`x` (行号 0-9), `y` (列号 0-9)。
    *   逻辑：
        1.  如果格子已翻开，忽略操作。
        2.  切换 Byte 2 的状态 (0 <-> 1)。
        3.  更新 `mines_left` 计数。
*   **`expand_blank(x, y)`** (内部递归函数)
    *   功能：递归翻开空白区域（泛洪算法）。
    *   逻辑：
        1.  翻开当前格子，`cells_left` 减 1。
        2.  如果 `cells_left == 0`，设置 `game_state = 3` (胜利)。
        3.  如果当前格子周围雷数为 0，则递归调用自身，尝试翻开周围 8 个格子。

### 3.3 状态获取
*   **`get_cell_state(x, y)`**
    *   功能：获取指定格子的完整 4 字节状态。
    *   返回值：EAX 寄存器包含该格子的所有信息。
*   **`get_game_state`**
    *   功能：(调试用) 打印当前整个棋盘的状态矩阵，方便观察逻辑是否正确。

## 4. 程序使用方法 (控制台测试版)

1.  运行程序 `minesweeper.exe`。
2.  程序会自动布雷并显示初始棋盘（调试模式下显示了所有信息）。
3.  在提示符 `Input: Op(1=Click, 2=Flag) Row Col:` 后输入三个数字，用空格分隔：
    *   **格式**：`操作类型 行号 列号`
    *   **示例 1 (翻开格子)**：`1 2 3`  -> 翻开第 2 行第 3 列。
    *   **示例 2 (插旗)**：`2 5 5` -> 在第 5 行第 5 列插旗。
4.  程序会根据操作更新棋盘并重新打印。
5.  如果踩雷，显示 "BOOM!..." 并退出。
6.  如果翻开所有非雷格子，显示 "Congratulations!..." 并退出。

## 5. 对接建议 (给界面组)
*   界面组只需调用 `click_cell` 和 `toggle_flag` 来响应鼠标事件。
*   界面重绘时，调用 `get_cell_state` 获取格子状态，根据返回值决定绘制什么图片（数字、旗帜、地雷或空白）。
*   每一帧或每次操作后，检查 `game_state` 变量来判断是否弹窗提示胜利/失败。
